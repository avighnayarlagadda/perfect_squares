// src/lukas.gleam
// Sequential Gleam solution â€” submission-ready.
// Usage: lukas <N> <k> [limit_print]

import gleam/io
import argv
import gleam/int
import gleam/list

// ---------- Math helpers ----------

fn sum_k_squares_from(s: Int, k: Int) -> Int {
  // c = (k-1)*k*(2k-1)/6
  let c = {k - 1} * k * {2 * k - 1} / 6
  k * s * s + k * {k - 1} * s + c
}

fn isqrt(low: Int, high: Int, n: Int) -> Int {
  case low > high {
    True -> high
    False -> {
      let mid = {low + high} / 2
      let sq = mid * mid
      case sq < n {
        True -> isqrt(mid + 1, high, n)
        False ->
          case sq > n {
            True -> isqrt(low, mid - 1, n)
            False -> mid
          }
      }
    }
  }
}

fn integer_sqrt(n: Int) -> Int {
  case n <= 1 {
    True -> n
    False -> isqrt(0, n, n)
  }
}

fn is_perfect_square(n: Int) -> Bool {
  case n < 0 {
    True -> False
    False -> {
      let r = integer_sqrt(n)
      r * r == n
    }
  }
}

fn find_solutions(n: Int, k: Int) -> List(Int) {
  list.range(1, n)
  |> list.filter(fn(s) { is_perfect_square(sum_k_squares_from(s, k)) })
}

// ---------- Printing helpers ----------

fn print_first(remaining: Int, items: List(Int)) -> Nil {
  case items {
    [] -> Nil
    [h, ..t] -> {
      case remaining <= 0 {
        True -> Nil
        False -> {
          io.println(int.to_string(h))
          print_first(remaining - 1, t)
        }
      }
    }
  }
}

// ---------- CLI + runner ----------

pub fn main() {
  let args = argv.load().arguments
  case args {
    [n_s, k_s] -> run_and_print(n_s, k_s, "0")
    [n_s, k_s, limit_s] -> run_and_print(n_s, k_s, limit_s)
    _ -> io.println("Usage: lukas <N> <k> [limit_print]")
  }
}

fn parse_int_or_default(s: String, d: Int) -> Int {
  case int.parse(s) {
    Ok(i) -> i
    Error(_) -> d
  }
}

fn run_and_print(n_s: String, k_s: String, limit_s: String) {
  let n = parse_int_or_default(n_s, 100)
  let k = parse_int_or_default(k_s, 2)
  let limit = parse_int_or_default(limit_s, 0) // 0 => print all

  let results = find_solutions(n, k)
  let total = list.length(results)

  io.println("---- Results (sorted) ----")
  io.println(
    "N: " <> int.to_string(n)
    <> "  k: " <> int.to_string(k)
    <> "  matches: " <> int.to_string(total)
  )

  case limit > 0 {
    True -> print_first(limit, results)
    False -> list.each(results, fn(x) { io.println(int.to_string(x)) })
  }
}
